{"version":3,"file":"index.js","sources":["../../src/client/composables/setupWatermark.ts","../../src/client/helper/watermark.ts"],"sourcesContent":["import { wait } from '@vuepress/helper/client'\nimport { watchImmediate } from '@vueuse/core'\nimport type { MaybeRef, Ref } from 'vue'\nimport { isRef, onMounted, toValue, watch } from 'vue'\nimport { useRoutePath, useSiteLocaleData, withBase } from 'vuepress/client'\nimport { Watermark } from 'watermark-js-plus'\nimport type { WatermarkOptions } from '../helper/index.js'\n\nexport const setupWatermark = (\n  options: MaybeRef<WatermarkOptions>,\n  enabled: Ref<boolean>,\n  delay = 500,\n): void => {\n  const routePath = useRoutePath()\n  const siteData = useSiteLocaleData()\n\n  onMounted(() => {\n    const watermark = new Watermark()\n\n    const updateWaterMark = (watermarkOptions: WatermarkOptions): void => {\n      const newOptions = {\n        // set default text to site title\n        content: siteData.value.title,\n        // set font color to make it readable both lightmode and darkmode\n        fontColor: '#76747f',\n        // default alpha of blind mode is 0.005 while default mode is 0.165\n        globalAlpha: watermarkOptions.mode === 'blind' ? 0.005 : 0.165,\n        ...watermarkOptions,\n      }\n\n      if (newOptions.image?.startsWith('/')) {\n        newOptions.image = withBase(newOptions.image)\n      }\n\n      if (toValue(enabled)) {\n        void watermark.changeOptions(newOptions)\n      }\n    }\n\n    watchImmediate(\n      [enabled, routePath],\n      async () => {\n        if (enabled.value) {\n          await wait(delay)\n          updateWaterMark(toValue(options))\n        } else {\n          watermark.destroy()\n        }\n      },\n      { flush: 'post' },\n    )\n\n    if (isRef(options)) watch(options, updateWaterMark)\n  })\n}\n","import { isFunction, isPlainObject } from '@vuepress/helper/client'\nimport { watchImmediate } from '@vueuse/core'\nimport type {\n  App,\n  ComputedRef,\n  InjectionKey,\n  MaybeRef,\n  MaybeRefOrGetter,\n  Ref,\n} from 'vue'\nimport { computed, inject, isRef, ref, toValue } from 'vue'\nimport { usePageFrontmatter } from 'vuepress/client'\nimport type { WatermarkOptions as WatermarkRawOptions } from 'watermark-js-plus'\nimport type { WatermarkPluginFrontmatter } from '../../shared/index.js'\n\nexport type WatermarkOptions = Partial<WatermarkRawOptions>\n\nconst watermarkSymbol: InjectionKey<Ref<WatermarkOptions>> = Symbol(\n  __VUEPRESS_DEV__ ? 'watermark' : '',\n)\n\nconst watermarkOptions = ref<WatermarkOptions>({})\n\n/**\n * Define additional watermark configurations in the client-side.\n *\n * In most cases, the majority of options should be defined in Node,\n * but there are some special situations. For example,\n * it may be necessary to control different watermark opacities, font colors,\n * etc., in dark/light mode, or to pass in callbacks such as `onSuccess`, `extraDrawFunc`, and so on.\n *\n * 在客户端中定义额外的水印配置。\n *\n * 通常来说，大部分选项应该在 Node 中定义，但存在一些特殊情况。\n * 比如需要在 深色/浅色 模式下控制不同的 水印 透明度、字体颜色等，\n * 或者需要传入如 `onSuccess`、`extraDrawFunc` 等回调函数。\n *\n * @example\n * ```ts\n * import { computed } from 'vue'\n *\n * const isDark = useDarkMode()\n *\n * const watermarkConfig = computed(() => ({\n *   fontColor: isDark.value ? '#fff' : '#000',\n *   onSuccess: () => {\n *     console.log('success')\n *   },\n * }))\n *\n * defineWatermarkConfig(watermarkConfig)\n * ```\n *\n * @param userConfig Watermark options\n *\n */\nexport const defineWatermarkConfig = (\n  userConfig: MaybeRefOrGetter<WatermarkOptions>,\n): void => {\n  if (isRef(userConfig)) {\n    watchImmediate(userConfig, (value) => {\n      watermarkOptions.value = value\n    })\n  } else if (isFunction(userConfig)) {\n    watchImmediate(computed(userConfig), (value) => {\n      watermarkOptions.value = value\n    })\n  } else {\n    watermarkOptions.value = userConfig\n  }\n}\n\nexport const useWatermarkOptions = (\n  options: MaybeRef<WatermarkOptions>,\n): ComputedRef<WatermarkOptions> => {\n  const globalOptions = inject(watermarkSymbol)!\n  const frontmatter = usePageFrontmatter<WatermarkPluginFrontmatter>()\n\n  return computed(() => {\n    const { watermark } = frontmatter.value\n\n    return {\n      ...toValue(options),\n      ...globalOptions.value,\n      ...(isPlainObject(watermark) ? watermark : {}),\n    }\n  })\n}\n\nexport const injectWatermarkConfig = (app: App): void => {\n  app.provide(watermarkSymbol, watermarkOptions)\n}\n"],"names":["setupWatermark","options","enabled","delay","routePath","useRoutePath","siteData","useSiteLocaleData","onMounted","watermark","Watermark","updateWaterMark","watermarkOptions","newOptions","withBase","toValue","watchImmediate","wait","isRef","watch","watermarkSymbol","ref","defineWatermarkConfig","userConfig","value","isFunction","computed","useWatermarkOptions","globalOptions","inject","frontmatter","usePageFrontmatter","isPlainObject","injectWatermarkConfig","app"],"mappings":"gYAQO,MAAMA,EAAiB,CAC5BC,EACAC,EACAC,EAAQ,MACC,CACT,MAAMC,EAAYC,EACZC,EAAAA,EAAWC,EAAkB,EAEnCC,EAAU,IAAM,CACd,MAAMC,EAAY,IAAIC,EAEhBC,EAAmBC,GAA6C,CACpE,MAAMC,EAAa,CAEjB,QAASP,EAAS,MAAM,MAExB,UAAW,UAEX,YAAaM,EAAiB,OAAS,QAAU,KAAQ,KACzD,GAAGA,CACL,EAEIC,EAAW,OAAO,WAAW,GAAG,IAClCA,EAAW,MAAQC,EAASD,EAAW,KAAK,GAG1CE,EAAQb,CAAO,GACZO,EAAU,cAAcI,CAAU,CAE3C,EAEAG,EACE,CAACd,EAASE,CAAS,EACnB,SAAY,CACNF,EAAQ,OACV,MAAMe,EAAKd,CAAK,EAChBQ,EAAgBI,EAAQd,CAAO,CAAC,GAEhCQ,EAAU,SAEd,EACA,CAAE,MAAO,MAAO,CAClB,EAEIS,EAAMjB,CAAO,GAAGkB,EAAMlB,EAASU,CAAe,CACpD,CAAC,CACH,ECrCMS,EAAuD,OAC3D,iBAAmB,YAAc,EACnC,EAEMR,EAAmBS,EAAsB,CAAA,CAAE,EAmCpCC,EACXC,GACS,CACLL,EAAMK,CAAU,EAClBP,EAAeO,EAAaC,GAAU,CACpCZ,EAAiB,MAAQY,CAC3B,CAAC,EACQC,EAAWF,CAAU,EAC9BP,EAAeU,EAASH,CAAU,EAAIC,GAAU,CAC9CZ,EAAiB,MAAQY,CAC3B,CAAC,EAEDZ,EAAiB,MAAQW,CAE7B,EAEaI,EACX1B,GACkC,CAClC,MAAM2B,EAAgBC,EAAOT,CAAe,EACtCU,EAAcC,EAEpB,EAAA,OAAOL,EAAS,IAAM,CACpB,KAAM,CAAE,UAAAjB,CAAU,EAAIqB,EAAY,MAElC,MAAO,CACL,GAAGf,EAAQd,CAAO,EAClB,GAAG2B,EAAc,MACjB,GAAII,EAAcvB,CAAS,EAAIA,EAAY,CAAA,CAC7C,CACF,CAAC,CACH,EAEawB,EAAyBC,GAAmB,CACvDA,EAAI,QAAQd,EAAiBR,CAAgB,CAC/C"}